/*******************************************************************************
 * Copyright (C) 2020, exense GmbH
 *  
 * This file is part of STEP
 *  
 * STEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *  
 * STEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *  
 * You should have received a copy of the GNU Affero General Public License
 * along with STEP.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package step.resources;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;

import step.core.entities.EntityConstants;
import step.core.imports.ImportConfiguration;
import step.core.imports.ImportContext;


public class ResourceImporter implements BiConsumer<Object, ImportContext> {

	private ResourceManager resourceManager;
	
	public ResourceImporter(ResourceManager resourceManager) {
		this.resourceManager = resourceManager;
	}
	
	@Override
	public void accept(Object t, ImportContext importContext) {
		if(t instanceof Resource) {
			Resource resource = (Resource) t;

			ImportConfiguration importConfiguration = importContext.getImportConfiguration();
			
			String origResourceId;
			String tmpCollectionCurrentRevisionId;
			//When importing a resource, we import all its revisions as found in the archive.
			//The current revision of the exported resource has to be imported last to become the current revision of the imported resource (that's how resourceManager.saveResourceContent works)
			//In the process we replace all new revision IDs in the references map (old ID to new ID) with the revision IDs generated by resourceManager.saveResourceContent
			if(importConfiguration.isOverwrite()) {
				origResourceId = resource.getId().toHexString();
				tmpCollectionCurrentRevisionId = resource.getCurrentRevisionId().toHexString();
			} else {
				origResourceId = importContext.getNewToOldReferences().get(resource.getId().toHexString());
				//Revisions were processed and IDs replaced in the tmp collection, but the field currentRevisionId of resources still refers to the original IDs, so we need to get the new one
				tmpCollectionCurrentRevisionId = importContext.getReferences().get(resource.getCurrentRevisionId().toHexString());
			}

			//We need to update the resource for each  saveResourceContent
			ResourceRevisionAccessorImpl resourceRevisionAbstractAccessor = new ResourceRevisionAccessorImpl(importContext.getTempCollectionFactory().getCollection(EntityConstants.resourceRevisions, ResourceRevision.class));
			AtomicReference<ResourceRevision> currentRevision = new AtomicReference<>(null);
			resourceRevisionAbstractAccessor.getResourceRevisionsByResourceId(origResourceId).forEachRemaining(resourceRevision -> {
				//Make sure we create the resource's current revision at the end
				if (!tmpCollectionCurrentRevisionId.equals(resourceRevision.getId().toHexString())) {
					importRevision(importContext, resourceRevision, resource, origResourceId, importConfiguration);
				} else {
					currentRevision.set(resourceRevision);
				}
			});
			//Create current revision
			if (currentRevision.get() != null) {
				importRevision(importContext, currentRevision.get(), resource, origResourceId, importConfiguration);
			} else {
				throw new RuntimeException("Error while updating resource content for resource " + origResourceId + ": the current revision " + tmpCollectionCurrentRevisionId + " was not found.");
			}
		}
	}

	private void importRevision(ImportContext importContext, ResourceRevision resourceRevision, Resource resource, String origResourceId, ImportConfiguration importConfiguration) {
		String origRevisionId = importConfiguration.isOverwrite() ? resourceRevision.getId().toHexString() :
				importContext.getNewToOldReferences().get(resourceRevision.getId().toHexString());
		Path path = ResourceManager.getResourceFilePath(importContext.getWorkFolder().getAbsolutePath(), resource.getResourceType(), origResourceId, origRevisionId, resourceRevision.getResourceFileName());
		try (InputStream fileInputStream = new FileInputStream(path.toFile())) {
			resourceManager.saveResourceContent(resource, fileInputStream, resourceRevision.getResourceFileName(), resource.getResourceName(), importConfiguration.getUsername());
			// Update the revision id reference
			importContext.getReferences().put(origRevisionId, resource.getCurrentRevisionId().toHexString());
		} catch (IOException | InvalidResourceFormatException e) {
			throw new RuntimeException("Error while updating resource content for resource " + origResourceId, e);
		}
	}
}
