package step.core.authentication;

import io.jsonwebtoken.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import step.core.deployment.AuthenticationException;
import step.framework.server.Session;

import jakarta.validation.constraints.NotNull;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

public class ResourceServerManager {

    private static Logger logger = LoggerFactory.getLogger(ResourceServerManager.class);

    private final JWTSettings jwtSettings;
    private final AuthorizationServerManager authorizationServerManager;

    private static Pattern claimsSplitPattern = Pattern.compile("->");

    public ResourceServerManager(JWTSettings jwtSettings, AuthorizationServerManager authorizationServerManager) {
        this.jwtSettings = jwtSettings;
        this.authorizationServerManager = authorizationServerManager;
    }

    public AuthenticationTokenDetails parseAndValidateToken(String token, Session session) throws AuthenticationException {
        AuthenticationTokenDetails tokenDetails;
        try {
            tokenDetails = parseToken(token);
            if (jwtSettings.isCheckIssuer() && !tokenDetails.getIssuer().equals(jwtSettings.getIssuer()))
                throw new InvalidAuthenticationTokenException("Token issuer is not valid");
            if (jwtSettings.isCheckAudience() && !tokenDetails.getAudience().equals(jwtSettings.getAudience()))
                throw new InvalidAuthenticationTokenException("Token for unexpected audience");
            //could be used to refuse old token event if set with unlimited exp time
             /*if (tokenDetails.getIssuedDate().isBefore(ZonedDateTime.now().minusYears(1)))
            throw new InvalidAuthenticationTokenException("Token is too old");*/
        } catch (ExpiredJwtException e) {
            //if token was generated by step itself and the session is still valid, we can safely refresh the  token
            String newToken = authorizationServerManager.refreshToken(session);
            tokenDetails = parseToken(newToken);
        }
        return  tokenDetails;
    }


    /**
     * Parse a JWT token.
     *
     * @param token
     * @return
     */
    private AuthenticationTokenDetails parseToken(String token) {

        try {

            JwtParser parser = Jwts.parser();
            SigningKeyResolver signingKeyResolver = authorizationServerManager.getSigningKeyResolver();
            if (signingKeyResolver == null) {
                parser.setSigningKey(jwtSettings.getSecret());
            } else {
                parser.setSigningKeyResolver(signingKeyResolver);
            }
            Jws<Claims> claimsJws = parser
                    .setAllowedClockSkewSeconds(jwtSettings.getClockSkew())
                    .parseClaimsJws(token);
            Claims claims = claimsJws.getBody();

            //TODO make this configurable
            return new AuthenticationTokenDetails.Builder()
                    .withId(extractTokenIdFromClaims(claims))
                    .withUsername(extractUsernameFromClaims(claims))
                    .withRole(extractRoleFromClaims(claims))
                    .withIssuer(extractIssuerFromClaims(claims))
                    .withAudience(extractAudienceFromClaims(claims))
                    //.withNotBeforeDate(extractNotBeforeDateFromClaims(claims))
                    .withIssuedDate(extractIssuedDateFromClaims(claims))
                    //.withExpirationDate(extractExpirationDateFromClaims(claims))
                    //.withRefreshCount(extractRefreshCountFromClaims(claims))
                    //.withRefreshLimit(extractRefreshLimitFromClaims(claims))
                    .build();

        } catch (UnsupportedJwtException | MalformedJwtException | IllegalArgumentException | SignatureException e) {
            throw new InvalidAuthenticationTokenException("Invalid token", e);
        } catch (ExpiredJwtException e) {
            throw e;
        } catch (InvalidClaimException e) {
            throw new InvalidAuthenticationTokenException("Invalid value for claim \"" + e.getClaimName() + "\"", e);
        } catch (Exception e) {
            throw new InvalidAuthenticationTokenException("Invalid token", e);
        }
    }

    /**
     * Extract the token identifier from the token claims.
     *
     * @param claims
     * @return Identifier of the JWT token
     */
    private String extractTokenIdFromClaims(@NotNull Claims claims) {
        return (String) claims.get(Claims.ID);
    }

    /**
     * Extract the username from the token claims.
     *
     * @param claims
     * @return Username from the JWT token
     */
    private String extractUsernameFromClaims(@NotNull Claims claims) {
        return getRecursiveClaimValue(jwtSettings.getUserClaimName(), claims, "");
    }

    /**
     * Extract the user authorities from the token claims.
     *
     * @param claims
     * @return User authorities from the JWT token
     */
    private String extractRoleFromClaims(@NotNull Claims claims) {
        return getRecursiveClaimValue(jwtSettings.getRoleClaimName(), claims, "");
    }

    private String extractIssuerFromClaims(@NotNull Claims claims) {
        return claims.getIssuer();
    }

    private String extractAudienceFromClaims(@NotNull Claims claims) {
        return claims.getAudience();
    }

    private ZonedDateTime extractNotBeforeDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getNotBefore().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the issued date from the token claims.
     *
     * @param claims
     * @return Issued date of the JWT token
     */
    private ZonedDateTime extractIssuedDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getIssuedAt().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the expiration date from the token claims.
     *
     * @param claims
     * @return Expiration date of the JWT token
     */
    private ZonedDateTime extractExpirationDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getExpiration().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the refresh count from the token claims.
     *
     * @param claims
     * @return Refresh count from the JWT token
     */
    private int extractRefreshCountFromClaims(@NotNull Claims claims) {
        return (int) claims.get(jwtSettings.getRefreshCountClaimName());
    }

    /**
     * Extract the refresh limit from the token claims.
     *
     * @param claims
     * @return Refresh limit from the JWT token
     */
    private int extractRefreshLimitFromClaims(@NotNull Claims claims) {
        return (int) claims.get(jwtSettings.getRefreshLimitClaimName());
    }

    private String getRecursiveClaimValue(String path, Map<String, Object> claims, String defaultValue) {
        Map<String, Object> current = claims;
        String[] splitPath = claimsSplitPattern.split(path);
        for (int i =0 ; i < splitPath.length ; i++ ) {
            Object o = current.get(splitPath[i]);
            if (i < (splitPath.length-1)) {
               if  (o instanceof Map) {
                   current = (Map) o;
               } else {
                   break;
               }
            } else if (i == (splitPath.length-1)){
                if (o instanceof String) {
                    return (String) o;
                } else if (o instanceof List) {
                    //TODO support returning list for list of roles?
                    return ((List<String>) o).get(0);
                }

            }
        }
        logger.error("Unable to extract the claim with path " + path + ", from : " + claims);
        return defaultValue;
    }

}
