package step.core.authentication;

import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.PathNotFoundException;
import io.jsonwebtoken.*;
import net.minidev.json.JSONValue;
import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import step.core.deployment.AuthenticationException;
import step.framework.server.Session;

import jakarta.validation.constraints.NotNull;

import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Map;
import java.util.Objects;
import java.util.regex.Pattern;

public class ResourceServerManager {

    private static Logger logger = LoggerFactory.getLogger(ResourceServerManager.class);

    private final JWTSettings jwtSettings;
    private final AuthorizationServerManager authorizationServerManager;

    private static Pattern claimsSplitPattern = Pattern.compile("->");

    public ResourceServerManager(JWTSettings jwtSettings, AuthorizationServerManager authorizationServerManager) {
        this.jwtSettings = jwtSettings;
        this.authorizationServerManager = authorizationServerManager;
    }

    public AuthenticationTokenDetails parseAndValidateToken(String token, Session session) throws AuthenticationException {
        AuthenticationTokenDetails tokenDetails;
        try {
            tokenDetails = parseToken(token);
            if (jwtSettings.isCheckIssuer() && !tokenDetails.getIssuer().equals(jwtSettings.getIssuer()))
                throw new InvalidAuthenticationTokenException("Token issuer is not valid");
            if (jwtSettings.isCheckAudience() && !tokenDetails.getAudience().equals(jwtSettings.getAudience()))
                throw new InvalidAuthenticationTokenException("Token for unexpected audience");
            //could be used to refuse old token event if set with unlimited exp time
             /*if (tokenDetails.getIssuedDate().isBefore(ZonedDateTime.now().minusYears(1)))
            throw new InvalidAuthenticationTokenException("Token is too old");*/
        } catch (ExpiredJwtException e) {
            //if token was generated by step itself and the session is still valid, we can safely refresh the  token
            String newToken = authorizationServerManager.refreshToken(session);
            tokenDetails = parseToken(newToken);
        }
        return  tokenDetails;
    }


    /**
     * Parse a JWT token.
     *
     * @param token
     * @return
     */
    private AuthenticationTokenDetails parseToken(String token) {

        try {

            JwtParser parser = Jwts.parser();
            SigningKeyResolver signingKeyResolver = authorizationServerManager.getSigningKeyResolver();
            if (signingKeyResolver == null) {
                parser.setSigningKey(jwtSettings.getSecret());
            } else {
                parser.setSigningKeyResolver(signingKeyResolver);
            }
            Jws<Claims> claimsJws = parser
                    .setAllowedClockSkewSeconds(jwtSettings.getClockSkew())
                    .parseClaimsJws(token);
            Claims claims = claimsJws.getBody();

            //TODO make this configurable
            return new AuthenticationTokenDetails.Builder()
                    .withId(extractTokenIdFromClaims(claims))
                    .withUsername(extractUsernameFromClaims(claims))
                    .withRole(extractRoleFromClaims(claims))
                    .withIssuer(extractIssuerFromClaims(claims))
                    .withAudience(extractAudienceFromClaims(claims))
                    //.withNotBeforeDate(extractNotBeforeDateFromClaims(claims))
                    .withIssuedDate(extractIssuedDateFromClaims(claims))
                    //.withExpirationDate(extractExpirationDateFromClaims(claims))
                    //.withRefreshCount(extractRefreshCountFromClaims(claims))
                    //.withRefreshLimit(extractRefreshLimitFromClaims(claims))
                    .build();

        } catch (UnsupportedJwtException | MalformedJwtException | IllegalArgumentException | SignatureException e) {
            throw new InvalidAuthenticationTokenException("Invalid token", e);
        } catch (ExpiredJwtException e) {
            throw e;
        } catch (InvalidClaimException e) {
            throw new InvalidAuthenticationTokenException("Invalid value for claim \"" + e.getClaimName() + "\"", e);
        } catch (Exception e) {
            throw new InvalidAuthenticationTokenException("Invalid token", e);
        }
    }

    /**
     * Extract the token identifier from the token claims.
     *
     * @param claims
     * @return Identifier of the JWT token
     */
    private String extractTokenIdFromClaims(@NotNull Claims claims) {
        return (String) claims.get(Claims.ID);
    }

    /**
     * Extract the username from the token claims.
     *
     * @param claims
     * @return Username from the JWT token
     */
    private String extractUsernameFromClaims(@NotNull Claims claims) {
        return Objects.requireNonNullElse(getValueForJsonPath(jwtSettings.getUserClaimJsonPath(), claims),"");
    }

    /**
     * Extract the user authorities from the token claims.
     *
     * @param claims
     * @return User authorities from the JWT token
     */
    private String extractRoleFromClaims(@NotNull Claims claims) {
        Map<String, JsonPath> roleJsonPaths = jwtSettings.getRoleClaimJsonPathMap();
        if (roleJsonPaths == null ||roleJsonPaths.isEmpty()) {
            return "";
        }
        return Objects.requireNonNullElse(getFirstKeyWithValidJsonPath(roleJsonPaths, claims),"");
    }

    private String getValueForJsonPath(JsonPath jsonPath, Claims claims) {
        JSONObject jsonObject = new JSONObject(claims);
        try {
            return jsonPath.read(jsonObject.toString());
        } catch (PathNotFoundException e) {
            logger.error("User was not found in JWT token with provided json path: " + jsonPath.getPath(), e);
            return null;
        }
    }

    private String getFirstKeyWithValidJsonPath(Map<String, JsonPath> jsonPathsMap, Claims claims) {
        JSONObject jsonObject = new JSONObject(claims);
        return jsonPathsMap.entrySet().stream().filter(e -> {
                Object read = null;
                try {
                    read = e.getValue().read(jsonObject.toString());
                } catch (PathNotFoundException ex) {
                    logger.warn("Json path with key " + e.getKey() + " and path " + e.getValue().getPath() + " was not found.", ex);
                }
                if (read == null) {
                    return false;
                } else if (read instanceof JSONArray) {
                    return !((JSONArray) read).isEmpty();
                } else if (read instanceof JSONObject) {
                    return !((JSONObject) read).keySet().isEmpty();
                } else if (read instanceof JSONValue) {
                    return !read.toString().isBlank();
                }
            return false;
        }).map(e -> e.getKey()).findFirst().orElse(null);
    }

    private String extractIssuerFromClaims(@NotNull Claims claims) {
        return claims.getIssuer();
    }

    private String extractAudienceFromClaims(@NotNull Claims claims) {
        return claims.getAudience();
    }

    private ZonedDateTime extractNotBeforeDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getNotBefore().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the issued date from the token claims.
     *
     * @param claims
     * @return Issued date of the JWT token
     */
    private ZonedDateTime extractIssuedDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getIssuedAt().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the expiration date from the token claims.
     *
     * @param claims
     * @return Expiration date of the JWT token
     */
    private ZonedDateTime extractExpirationDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getExpiration().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the refresh count from the token claims.
     *
     * @param claims
     * @return Refresh count from the JWT token
     */
    private int extractRefreshCountFromClaims(@NotNull Claims claims) {
        return (int) claims.get(jwtSettings.getRefreshCountClaimName());
    }

    /**
     * Extract the refresh limit from the token claims.
     *
     * @param claims
     * @return Refresh limit from the JWT token
     */
    private int extractRefreshLimitFromClaims(@NotNull Claims claims) {
        return (int) claims.get(jwtSettings.getRefreshLimitClaimName());
    }

}
