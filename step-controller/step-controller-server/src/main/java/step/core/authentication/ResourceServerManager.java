package step.core.authentication;

import io.jsonwebtoken.*;
import step.framework.server.Session;

import jakarta.validation.constraints.NotNull;
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class ResourceServerManager {

    private final JWTSettings jwtSettings;
    private final AuthorizationServerManager authorizationServerManager;

    public ResourceServerManager(JWTSettings jwtSettings, AuthorizationServerManager authorizationServerManager) {
        this.jwtSettings = jwtSettings;
        this.authorizationServerManager = authorizationServerManager;
    }

    public AuthenticationTokenDetails parseAndValidateToken(String token, Session session) {
        AuthenticationTokenDetails tokenDetails;
        try {
            tokenDetails = parseToken(token);
            if (jwtSettings.isCheckIssuer() && !tokenDetails.getIssuer().equals(jwtSettings.getIssuer()))
                throw new InvalidAuthenticationTokenException("Token issuer is not valid");
            if (jwtSettings.isCheckAudience() && !tokenDetails.getAudience().equals(jwtSettings.getAudience()))
                throw new InvalidAuthenticationTokenException("Token for unexpected audience");
            //could be used to refuse old token event if set with unlimited exp time
             /*if (tokenDetails.getIssuedDate().isBefore(ZonedDateTime.now().minusYears(1)))
            throw new InvalidAuthenticationTokenException("Token is too old");*/
        } catch (ExpiredJwtException e) {
            if (session != null && session.isLocalToken()) {
                //if token was generated by step itself and the session is still valid, we can safely refresh the  token
                String newToken = authorizationServerManager.refreshToken(session);
                tokenDetails = parseToken(newToken);
            } else {
                throw e;
            }
        }
        return  tokenDetails;
    }


    /**
     * Parse a JWT token.
     *
     * @param token
     * @return
     */
    private AuthenticationTokenDetails parseToken(String token) {

        try {

            JwtParser parser = Jwts.parser();
            SigningKeyResolver signingKeyResolver = authorizationServerManager.getSigningKeyResolver();
            if (signingKeyResolver == null) {
                parser.setSigningKey(jwtSettings.getSecret());
            } else {
                parser.setSigningKeyResolver(signingKeyResolver);
            }
            Jws<Claims> claimsJws = parser
                    .setAllowedClockSkewSeconds(jwtSettings.getClockSkew())
                    .parseClaimsJws(token);
            Claims claims = claimsJws.getBody();

            //TODO make this configurable
            return new AuthenticationTokenDetails.Builder()
                    .withId(extractTokenIdFromClaims(claims))
                    .withUsername(extractUsernameFromClaims(claims))
                    .withRole(extractRoleFromClaims(claims))
                    .withIssuer(extractIssuerFromClaims(claims))
                    .withAudience(extractAudienceFromClaims(claims))
                    //.withNotBeforeDate(extractNotBeforeDateFromClaims(claims))
                    .withIssuedDate(extractIssuedDateFromClaims(claims))
                    //.withExpirationDate(extractExpirationDateFromClaims(claims))
                    //.withRefreshCount(extractRefreshCountFromClaims(claims))
                    //.withRefreshLimit(extractRefreshLimitFromClaims(claims))
                    .build();

        } catch (UnsupportedJwtException | MalformedJwtException | IllegalArgumentException | SignatureException e) {
            throw new InvalidAuthenticationTokenException("Invalid token", e);
        } catch (ExpiredJwtException e) {
            throw e;
        } catch (InvalidClaimException e) {
            throw new InvalidAuthenticationTokenException("Invalid value for claim \"" + e.getClaimName() + "\"", e);
        } catch (Exception e) {
            throw new InvalidAuthenticationTokenException("Invalid token", e);
        }
    }

    /**
     * Extract the token identifier from the token claims.
     *
     * @param claims
     * @return Identifier of the JWT token
     */
    private String extractTokenIdFromClaims(@NotNull Claims claims) {
        return (String) claims.get(Claims.ID);
    }

    /**
     * Extract the username from the token claims.
     *
     * @param claims
     * @return Username from the JWT token
     */
    private String extractUsernameFromClaims(@NotNull Claims claims) {
        return (String) claims.get(jwtSettings.getUserClaimName());
    }

    /**
     * Extract the user authorities from the token claims.
     *
     * @param claims
     * @return User authorities from the JWT token
     */
    private String extractRoleFromClaims(@NotNull Claims claims) {
        String rolesAsString = (String) claims.getOrDefault(jwtSettings.getRoleClaimName(), "");
        return rolesAsString;
    }

    private String extractIssuerFromClaims(@NotNull Claims claims) {
        return claims.getIssuer();
    }

    private String extractAudienceFromClaims(@NotNull Claims claims) {
        return claims.getAudience();
    }

    private ZonedDateTime extractNotBeforeDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getNotBefore().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the issued date from the token claims.
     *
     * @param claims
     * @return Issued date of the JWT token
     */
    private ZonedDateTime extractIssuedDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getIssuedAt().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the expiration date from the token claims.
     *
     * @param claims
     * @return Expiration date of the JWT token
     */
    private ZonedDateTime extractExpirationDateFromClaims(@NotNull Claims claims) {
        return ZonedDateTime.ofInstant(claims.getExpiration().toInstant(), ZoneId.systemDefault());
    }

    /**
     * Extract the refresh count from the token claims.
     *
     * @param claims
     * @return Refresh count from the JWT token
     */
    private int extractRefreshCountFromClaims(@NotNull Claims claims) {
        return (int) claims.get(jwtSettings.getRefreshCountClaimName());
    }

    /**
     * Extract the refresh limit from the token claims.
     *
     * @param claims
     * @return Refresh limit from the JWT token
     */
    private int extractRefreshLimitFromClaims(@NotNull Claims claims) {
        return (int) claims.get(jwtSettings.getRefreshLimitClaimName());
    }


}
